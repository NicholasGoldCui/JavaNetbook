## 4.5 逻辑运算符与逻辑表达式
### 4.5.1 逻辑运算符
| 符号 | 功能 | 示例 | 含义 |
| --- | --- | --- | --- |
| && | 逻辑与 | A&&B | A、B两个只要有一个为假，都为假。其余情况都为真 |
| //通道符本来是竖线符的 | 逻辑或 | A||B | A、B两个只要有一个为真，都为真。其余情况都为假 |
| ! | 逻辑非 | !A | A表达式为真，结果为假，A表达式为假，结果为真 |
### 4.5.2 逻辑表达式
使用逻辑运算符，可以将多个关系表达式的结果合并在一起进行判断。其一般形式如下：

表达式 逻辑运算符 表达式

### 4.5.3 优先级与结合性
“&&”和“||”是双目运算符，要求有两个操作数，结合方向自作至右；“！”是单目运算符，要求有一个操作数，结合方向自右向左。逻辑运算符的优先级从高到低依次为“！”“&&”和“||”。
## 4.6 逗号运算符与逗号表达式
C语言中，可用逗号运算符将多个表达式分隔开来。逗号表达式的一般形式如下：

表达式1,表达式2,表达式3,表达式4,……,表达式n

逗号表达式又称为顺序求值运算符，其求解过程是：先求解表达式1，再求解表达式2，一直求解到表达式n。整个逗号表达式的值是表达式n的值。
但观察下面的逗号表达式：
```C
Value = 2+5,1+2,5+7;
```
上述语句中，Value的值为7，而非12。这个问题在于优先级。**赋值运算符的优先级比逗号运算符高**，因此先执行赋值运算。如果要先执行逗号运算，在可以使用括号运算符，代码如下：
```C
Value = (2+5, 1+2, 5+7);
```
使用括号之后，Value的值为12。

## 4.7 复合赋值运算符
复合赋值运算符是C语言所独有的，实际这种操作是一种缩写形式，可使变量操作的描述方式更简洁。例如，为变量Value赋值，值为Value自身与3相加的结果，代码如下：
```C
Value = Value + 3;
```
使用复合赋值运算符，可以实现同样的操作，但描述更为简洁。代码如下：
```C
Value+=3;
```
可见，使用复合赋值运算符不但可以简化程序，使代码更为精炼，而且可以提高编译效率。
## 4.8 运算符的优先级总结
| 优先级 | 运算符 | 含义 | 结合性 |
| --- | --- | --- | --- |
| 1 | () | 圆括号 | 自左向右 |
| 1 | [] | 下标运算符 |
| 1 | -> | 指向结构体成员运算符 |
| 1 | . | 结构体成员运算符 |
| 2 | ! | 逻辑非运算符(单目运算符) | 自右向左 |
| 2 | ~ | 按位取反运算符(单目运算符) |
| 2 | ++ | 自增运算符(单目运算符) |
| 2 | -- | 自减运算符(单目运算符) |
| 2 | - | 负号运算符(单目运算符) |
| 2 | * | 指针运算符(单目运算符) |
| 2 | & | 地址与运算符(单目运算符) |
| 2 | sizeof | 长度运算符(单目运算符) |
| 3 | `*`、/、% | 乘法、除法、求余运算符 | 自左向右 |
| 4 | +、- | 加法、减法运算符 |
| 5 | <<、>> | 左移、右移运算符 |
| 6 | <、<=、>、>= | 小于、小于或等于、大于、大于或等于运算符 |
| 7 | ==、!= | 等于、不等于运算符 |
| 8 | & | 按位与运算符 |
| 9 | ^ | 按位异运算符 |
| 10 | | | 按位或运算符 |
| 11 | && | 逻辑与运算符 |
| 12 | || | 逻辑或运算符 |
| 13 | ?: | 条件运算符(三目运算符) | 自右向左 |
| 14 | =、+=、-=、`*`=、/=、%=、>>=、<<=、&=、^=、|= | 赋值运算符
| 15 | , | 逗号运算符(顺序求值运算符) | 自左向右 |

# 第5章 常用的数据输入/输出函数
C语言中，语句是用来向计算机系统发出操作指令的。当需要程序按照用户输入信息执行指令时，先要使用输入语句给程序发送指示。
一条语句经过编译后，会产生若干条机器指令。实际程序中通常包含若干条语句，用于完成一定的操作任务。
**注意**
在编写程序时，声明部分不能算作语句。例如，“int iNumber;”就不是一条语句，因为不产生机器的操作，只是对变量提前进行了定义。
通过前面的介绍可知，程序包括声明部分和执行部分，其中执行部分由语句组成。
## 5.2 字符数据的输入/输出
### 5.2.1 字符输出函数
输入出字符数据使用的时putchar函数，作用是向显示设备输出一个字符。其语法格式如下：
```C
int putchar(int ch);
```
使用该函数时，要**添加文件stdio.h**。其中，参数ch为要输出的字符，可以是字符型变量或整型变量，也可以是常量。例如，输入出字符A的代码如下：
```C
putchar('A');
```
使用putchar函数也可以输出转义字符。例如，使用转义字符输出字符A：
```C
putchar('\101');
```
**注意**
1. 要使用putchar函数，首先要包含文件stdio.h。
2. putchar函数一次只能输出一个字符。要输出字符画，就需要多次调用putchar函数。
3. 字符画输出完毕后，使用putchar函数输出转义字符“\n”，进行换行操作。
### 5.2.2 字符输入函数
字符数据输入使用的是getchar函数，其作用是从终端(输入设备)输入一个字符。getchar与putchar函数的区别在于getchr函数没有参数。
使用getchar函数时，需要先添加头文件stdio.h。getchar函数的语法格式如下：
```C
int getchar();
```
函数的值就是从输入设备得到的字符。例如，从键盘输入一个字符并赋给变量cChar，代码如下：
```C
cChar=getchar();
```
**注意**
getchar函数只能接收一个字符，该字符可以赋给一个字符变量或整型变量，也可以不赋给任何变量，只作为表达式的一部分，如“putchar(getchar());。这里，getchar函数作为putchar函数的参数通过getchar寒素从输入设备得到一个字符，然后通过putchar函数将字符输出。
**注意**
getchar函数也可以不返回值，而是直接放在printf函数中使用。例如，
```C
printf("%c\n",getchar());
```
## 5.3 字符串输入/输出
putchar和getchar函数都只能对单个字符进行操作，如果要操作字符串，则会很麻烦。C语言提供了两个专门对字符串进行操作的函数，分别为gets和puts函数。
### 5.3.1 字符串输出函数
字符串输出使用的是puts函数，作用是输出一个字符串到屏幕上。其语法格式如下：
```C
int puts(char*str);
```
使用puts函数时，先要在程序中添加stdio.h头文件。其中，形式参数str是一个字符指针变量，用来接收要输出的字符串。例如，使用puts函数输出一个字符串：
```C
puts("I LOVE CHINA!");    /*输出一个字符串常量*/
```
上述语句首先会输出一个字符串，之后会自动进行换行操作。这与printf函数有所不同，在前几章的实例中，使用printf函数进行换行时，要在其中添加转义字符“\n”。
puts函数会在字符串中判断“\0” **结束符**，遇到结束符时，后面的字符**不再输出**，并且自动换行。例如：
```C
puts("I LOVE\0 CHINA!");
```
在上面的语句中，加上“\0”字符后，puts函数输出字符串就变成了“I LOVE”。
**说明**
前面介绍到，编译器会在字符串常量末尾自动添加“\0”结束符，因此puts函数会在输出字符串常量后自动进行换行操作。
**注意**
1. 第一次使用puts函数输出的字符串常量中，由于在该字符串中没有结束符“\0”，所以会完整输出整个字符串，直到最后编译器为其添加结束符“\0”为止。
2. 第二次使用puts函数输出的字符串常量中，人为添加两个“\0”，因此只能输出第一个结束符之前得到字符，然后进行换行操作。
3. 改变变量的值，在使用puts函数输出变量时，由于变量的值中包含一个结束符“\0”，因此将输出第一个结束符之前的所有字符，然后进行换行操作。
### 5.3.2 字符串输入函数
字符串输入使用的是gets函数，作用是将读取的字符串(即用户输入的字符串)保存在str变量中，直到出现新的一行为止。其新行的换行符将会转换为空终止符“\0”。
使用gets函数前，要添加头文件stdio.h。gets函数的语法格式如下：
```C
char *gets(char *str);
```

## 5.4 格式输出函数
printf函数是格式输出函数。
printf函数的作用是向终端(输出设备)输出若干任意类型的数据，其语法格式如下：
```C
printf(格式控制输出列表);
```
1. 格式控制
格式控制是用双引号括起来的字符串，也称为转换字符串。其中包括格式字符和普通字符。
+ 格式字符：用来进行格式说明的字符，作用是将输出的数据转换为指定的格式。格式字符通常以“%”开头。
+ 普通字符：需要原样输出的字符，包括双引号内的逗号、空格和换行符。
2. 输出列表
输出列表列出的是要进行输出的一些数据，可以是变量或表达式。
例如，要输出一个整型变量，代码如下：
```C
int iInt=10;
printf("this is %d", iInt);
```
其中的“this is”字符串是普通字符，而“%d”是格式字符，表示输出的是后面的iInt数据。
printf是函数，“格式控制”和“输出列表”都是函数参数，因此printf函数的一般形式可表示为：
```C
printf(参数1,参数2,……,参数n);
```
函数中的每个参数都必须按照给定的格式和顺序依次输出。例如，输出一个字符型变量和整型变量的代码如下：
```C
printf("this int is %d,the Char is %c", iInt,cChar);
```
printf函数的格式字符
| 格式字符 | 功能说明 |
| --- | --- |
| %d, %i | 用来输出**有符号**的**十进制整数** |
| %u | 用来输出无符号的十进制整数 |
| %o | 用来输出无符号的八进制整数 |
| %x, %X | 用来输出无符号的十六进制整数。%x表示以小写形式输出；%X表示以大写形式输出 |
| %c | 用来输出**单个字符** |
| %s | 用来输出**字符串** |
| %f | 用来输出实数，以小写形式输出 |
| %e, %E | 用来输出实数，以指数形式输出 |
| %g, %G | 以%f或%e中宽度较短的格式输出，不输出无意义的0 |
**注意**
printf函数中，除X、E、G外，其他格式字符必须使用小写字母，如%d不能写成%D。
另外，在格式说明中，在“%”符号和上述格式字符间可以插入集中附加符号。
printf函数的附加格式说明字符
| 附加字符 | 功能说明 |
| --- | --- |
| l | 用于输出长整型整数，可加在d、o、x、u的字母前面 |
| m | 用于指定输出数据的字段宽度，数字或字符在域内向右对齐 |
| n | 对实数，表示输出n位小数；对字符串，表示截取的字符个数 |
| - | 用于指定输出的数字或字符在域内向左对齐 |
如果向输出“%”符号，可在格式控制处使用“%%”进行输出。
“%-10.2s”格式为“-m.ns”，其中m、n含义同上，n个字符输出在m列的左侧，右补空。如果n>m，则m自动取n值，即保证n个字符正常输出

## 5.5 格式输入函数
与格式输出函数printf相对应的是格式输入函数scanf。该函数的功能是按照指定的格式接收用户在键盘上输入的数据，最后将数据存储在指定的变量中。
scanf函数的一般格式如下：
```C
scanf(格式控制，地址列表);
```
其中，“格式控制”参数与printf函数相同，“%d”表示十进制整型，“%c”表示单个字符；“地址列表”参数用于接收数据变量的地址。
**注意**
scanf函数参数的“地址列表”处要使用变量地址，而不是变量的标识符，否则会编译报错。

例如，得到一个整型数据的代码如下：
```C
scanf("%d", &iInt);
```
在上面的代码中，“&”是取地址符号，表示取iInt变量的地址。用户不用关心变量的地址具体是多少，只要在变量的标识符前加“&”，就可以表示取变量的地址。
**注意**
scanf函数中，当输入的数据是基本类型，如整型、字符型、实型时，需要使用取地址符号。当输入的变量本身就是一个地址时，如数组名、字符串指针等，不需要再使用“&”符号。
scanf函数的格式字符
| 格式字符 | 功能说明 |
| --- | --- |
| %d, %i | 用来输入**有符号**的十进制整数 |
| %u | 用来输入**无符号**十进制整数 |
| %o | 用来输入无符号的八进制整数 |
| %x, %X | 用来输入无符号的十六进制整数(大小写作用相同) |
| %c | 用啦输入**单个字符** |
| %s | 用来输入字符串 |
| %f | 用来输入实数，以小数形式输入 |
| %e, %E | 用来输入实数，以指数形式输入 |
| %g, %G | 用来输入实数， 以%f和%e作用相同 |
**注意**
格式字符“%s”用来输入字符串。将字符串送到一个字符数组中，在输入时以非空白字符开始，以第一个空白字符结束。字符串以串结束标志“\0”作为最后一个字符。
**注意**
+ scanf函数只能接收输入的数据，不能显示信息，所以先使用printf函数输出一段信息提示。
+ 调用scanf格式输入函数，在函数参数中使用双引号将格式字符括起来，“%f”表示输入的时十进制的小数。在参数中的地址列表位置使用“&”符号表示变量的地址。
+ scanf函数使用的时变量的标识符，而不是变量地址。scanf函数使用的是变量地址，而不是变量的标识符。
**说明**
程序是怎样将输入的内容分别保存到两个指定变量中的呢？scanf函数使用空白字符分隔输入的数据，这些空白字符包括空格、换行和制表符(tab)。本例中使用了换行作为空白字符。
**注意**
使用scanf函数输入数据时，实际输入的变量格式必须与scanf函数参数中指定的变量格式、顺序一一对应。
如果scanf函数里使用的格式列表是这样的“%d#%c#%f”，那么在输入数据时，就需要使用“#”进行分隔。

相应地，scanf函数中也有附加格式，用于更为具体的格式说明。
+ scanf函数的附加格式说明字符
| 附加字符 | 功能说明 |
| --- | --- |
| l | 用于输入长整型数据(如%ld、%lo、%lx、%lu)以及double型数据(如%lf、%le) |
| h | 用于输入短整型数据(如%hd、%ho、%hx) |
| n | 用于指定输入数据的字段宽度，多余的数据呗忽略 |
| * | 表示指定的输入项在读入后不赋给相应的变量 |
**注意**
+ 为了scanf函数能接收数据，需要在程序代码中先定义所使用的变量。为了演示不同格式的字符的情况，定义的变量类型有长整型、短整型和字符数组。
+ 使用printf函数显示数据提示，提示待输入的数据为长整型，调用scanf函数使变量iLong得到用户输入的数据。在scanf函数的格式控制部分，使用附加格式字符l表示长整型。

## 5.6 顺序程序设计应用
英文大小写字符互相转换
```C
#include<stdio.h>

int main()
{
  char cBig;    /*定义字符变量，表示大写字母*/
  char cSmall;  /*定义字符变量，表示小写字母*/
  
  puts("Please enter capital character:");  /*输出提示信息*/
  cBig=getchar();   /*得到用户输入的大写字符*/
  puts("Minuscule character is:");  /*输出提示信息*/
  cSmall=cBig+32;   /*将大写字符转换成小写字符*/
  printf("%c\n",cSmall);    /*输出小写字符*/
  return 0;   /*程序结束*/
}
```
# 第6章 选择结构程序设计
## 6.1 if语句
## 6.2 if语句的基本形式
### 6.2.1 if语句形式
if语句的一般形式如下：
```C
if(表达式) 语句
```
进行条件判断。如果if判断括号中的表达式为真(非0)，就执行后面的语句；如果为假(0)，则不执行后面的语句。
```C
if(iNum) printf("The truevalue");
```
上面的语句是一条。如果有两条语句，又该怎么办呢？
例如：
```C
if(iSignal==1)
{
  printf("The signal Light is%d:\n",iSignal);
  printf("Cars can run");
}
```
**误区警示**
if语句的括号后一定不要加英文分号(;)，否则将编译报错。

### 6.2.2 if……else语句形式
一般形式：
```C
if(表达式)
{
  语句块1;
}
else
{
  语句块2;
}
```
**注意**
else语句必须跟在一个if语句的后面，不能独立使用。

**误区警示**
在使用if语句比较浮点数时，不要使用浮点值，这样就会导致实际结果的偏差，因为浮点值属于近似值。
### 6.2.3 else if语句形式
利用if和else关键字的组合，可以实现else if语句。该语句可对一系列互斥的条件进行检验，从而解决较复杂的判断和决策问题。
一般形式如下：
```C
if(表达式1)
{
  语句块1；
}
else if(表达式2)
{
  语句块2;
}
else if(表达式m)
{
  语句块m;
}
else
{
  语句块n;
}
```
**误区警示**
使用多个else if语句时，要格外注意下方的复合语句(即语句块)部分，大括号一定要保证成对匹配。

## 6.4 条件运算符
首先来用if语句实现对两个数中最大值的求解，代码如下：
```C
if(a>b)
  {max=a;}
else
  {max=b;}
```
上面的代码可以用条件运算符"?:"来简化：
```C
max=(a>b)?a:b;
```
条件运算符可对一个表达式中值的真假情况进行检验，然后根据结果返回另外两个表达式中的一个，条件运算符的一般形式如下：

表达式1?表达式2:表达式3;

## 6.5 switch语句
### 6.5.1 switch语句的基本形式
switch语句是多分支选择语句，一般形式如下：
```C
switch(表达式)
{
  case 情况1:
      语句块1;
      break;
  case 情况2:
      语句块2;
      break;
   ……
   case 情况n:
      语句块n;
      break;
   default:
      默认语句块;
      break;
}
```
**注意**
switch语句检验的条件必须是一个整型表达式，这意味着其中也可以包含运算符和函数调用。而case语句检验的值必须是整型常量，即常量表达式或者常量运算。default可以省略。其中，任意两个case语句都不能使用相同的常量值；每个switch结构只能有一个default语句。在case语句表示的条件后有一个冒号“:”。当情况1正确后，若**没有**break语句case语句还会**接着判断**
### 6.5.2 多路开关模式的switch语句
将某个case语句后的语句块及break去掉之后，可以设计出多路开关模式的switch语句。例如：
```C
switch(表达式)
{
  case 1:
      语句1;
  case 2:
  case 3:
      语句3;
      
  ……
  default:
      默认语句;
}
```
可以看到，如果在case2后不使用break语句，那么符合case2检验与符合case3检验时的输出效果是一样的。也就是说，多路开关模式可使得多种检验条件执行同一个操作。

## 6.6 if……else语句和switch语句的区别
if……else语句和switch语句都可根据不同的情况检验条件，并做出相应的判断。
1. 语法的比较
使用时，if需要配合else关键字，switch需要配合case关键字；if语句是先对条件进行判断，而switch语句是后进行判断。
2. 效率的比较
if……else结构对少量的检验，判断速度比较快。但是随着检验深度的增长，会逐渐变慢，并且也不容易进行后续的条件添加和扩充。
switch结构中，除default默认情况外，对其他每一项case的检验速度都是相同的。default默认情况比其他情况都快。
当需要判定的情况较少时，使用if……else结构比使用switch结构检验速度快。也就是说，如果分支在3个或者4个以下，用if……else结构比较好，否则应选择switch结构。

# 第7章 循环控制
## 7.1 循环语句
C语言中有3种循环语句，即while、do……while和for循环语句。
## 7.2 while语句
使用while语句可以解决当某个条件满足时反复执行某个循环体的问题。其一般形式如下：
```C
while(表达式)
{
  语句块(循环体)
}
```
**说明**
无法终止的循环常被称为死循环或者无限循环。

**误区警示**
初学者很容易在while语句后添加英文分号(;)，从而导致编译报错。**一定要注意**，if、if……else、while语句的判断表达式是没有分号的。
使用while语句时，很容易多执行一次或少执行一次循环，这类错误被称为“**差一错误**”。例如，把“number<=20”写作“number<20”，就会少执行一次循环，因此一定要给出正确的循环条件。
## 7.3 do……while语句
在有些情况下，不论条件是否满足，循环过程必须执行至少一次，这时可以采用do……while语句。do……while语句的特点就是先执行循环体语句块中的内容，然后再判读循环条件是否成立。其一般形式如下：
```C
do
{
  语句块(循环体)
}while(表达式);
```
先执行后判断
**说明**
while语句和do……while语句的区别在于：while语句在每次循环之前检验条件，do……while语句在每次循环之后检验条件。
在使用do……while语句时，条件表达式要放在while关键字后面的括号中，最后必须加上一个分号(;)，这里和while语句不同。

## 7.4 for语句
C语言中，使用for语句也可以控制一个循环，并且在每次循环时修改循环变量。在循环语句中，for语句的应用最为灵活，可以用于循环次数确定的情况，还可以用于循环每次数不确定但给出了循环结束条件的情况。
### 7.4.1 for循环语句
for语句的一般形式如下：
```C
for(表达式1; 表达式2; 表达式3;)
{
  语句块(循环体)
}
```
每条for语句包含3个用分号隔开的表达式。这3个表达式用一对圆括号括起来，其后紧跟着循环语句或语句块。
执行for语句表达式的值。首先计算第1个表达式的值，接着计算第2个表达式的值。如果第2个表达式的值为真，程序就执行循环体的内容，并计算第3个表达式；然后检验第2个表达式，执行循环；如此反复，直到第2个表达式的值为假，退出循环。
for语句的形式也可以简单**表示**为：
```C
for(循环变量赋初值; 循环条件; 循环变量改变)
{
  语句块;
}
```
例如，实现一个循环输出操作：
```C
for(i=1; i<100; i++)
{
  printf("the is:%d", i);
}
```

### 7.4.2 for循环的变体
for语句的一般形式中有3个表达式。这3个表达式都是必不可少的，还是可以根据情况进行省略呢？
1. for语句中省略表达式1
表达式1的作用时的对循环变量设置初值，如果省略了表达式1，就会影响对表达式2(即循环条件)的判断。为保证程序正常运行，应在for语句之前先给循环变量赋值。例如，
```C
for(; iNumber<10; iNumber++)
```
**注意**
省略表达式1时，其后的分号不能省略，要格外注意。

2. for语句中省略表达式2
表达式2给出的是循环条件，如果表达式2省略，则无法判断循环条件，也即**默认表达式2** **始终为真**，因此循环将无终止地进行下去。例如：
```C
for(iCount=1; ; iCount++)   /*缺少循环结束条件，陷入死循环*/
{
  sum=sum+iCount;
}
```
3. for语句中省略表达式3
表达式3用于改变循环变量，也可以省略，但此时程序设计人员应在循环体内增加类似功能的语句，以保证循环能正常结束，否则程序也会无终止地循环下去。例如：
```C
for(iCount=1; iCount<50;)   /*for循环，省略表达式3*/
{
  sum=sum+iCount;
  iCount++;     /*此处语句可代替表达式3的功能*/
}
```

### 7.4.3 for循环中的逗号应用
在for语句中，表达式1和表达式3处除了可以使用简单的表达式，还可以使用逗号表达式，即包含一个以上的简单表达式，中间用逗号间隔。
**误区警示**
浮点值的误差是不可避免的。如果在for循环的条件表达式中使用浮点值，那么将导致数值错误。因此，建议开发者不要使用浮点类型定义for语句的循环变量。

## 7.5 3种循环语句的比较
前面介绍了3种可以执行循环操作的语句。一般情况下，这3种循环之间可以相互替换。下面是这3种的比较：
+ while和do……while循环只在while后面指定循环条件，在循环体种应包含使循环趋于结束的语句(如i++或者i=i+1等)。

## 7.6 循环嵌套
一个循环体内还可以包含一个或多个其他循环结构，这称之为循环的嵌套。

## 7.7 转移语句
转移语句包括goto语句、break语句和continue语句。通过这3种语句，程序的执行流程会发生一定的转移。
### 7.7.1 goto语句
goto语句为无条件转移语句，可以使程序立即跳转到函数内部的任意一条可执行语句处。goto关键字后面带一个标识符，该标识符是同一个函数内某条语句的标号。标号可以出现在任何可执行语句的的前面，并且以一个冒号“:”作为后缀。goto语句的一般形式如下：
```C
goto 标识符;
```
goto后的标识符就是要跳转的目标，当然这个标识符要在程序的其他位置给出，并且其标识符要位于函数内部。例如，
```C
goto Shwo;
printf("the message before ShowMessage");
Show:
    printf("ShowMessage");
```
**注意**
跳转的方向可以向前，也可以向后；可以跳出一个循环，也可以跳入一个循环。

### 7.7.2 break语句
有时会遇到这样的情况：不管表达式检验的结果如何，都需要情形终止循环，这时可以使用break语句。break语句用于终止并跳出当前循环，然后继续执行后面的代码。break语句的一般形式如下：
```C
break;
```
**注意**
循环体中的break语句和switch……case分支结构中的break语句的作用是不同的。

### 7.7.3 continue语句
在某些情况下，程序需要返回到循环头部继续执行，而不是跳出循环，此时可以使用continue语句。continue语句的一般形式如下：
```C
continue;
```
其作用就是结束本次循环，即跳过循环体中尚未执行的部分，直接执行下一次的循环操作。
**注意**
continue语句和break语句的区别是：continue语句只结束本次循环，而不是终止整个循环的执行；break语句则是结束整个循环过程，不再判断执行循环的条件是否成立。

# 第8章 数组

## 8.1 一维数组

### 8.1.1 一维数组的定义和引用
1. 一维数组的定义
一维数组实际上是一组相同类型数据的线性集合。其定义形式如下：
```C
类型说明符 数组标识符[常量表达式];
```
+ 类型说明符：表示数组中元素的类型。
+ 数组标识符：表示该数组型变量的名称，命名规则与变量名一致。
+ 常量表达式：定义了数组中存放的数据元素个数，即数组长度。

例如，定义一个包含5个整型元素的数组，代码如下：
```C
int iArray[5];
```
代码中的int为数组元素的类型，iArray为数组变量名，括号中的5表示数组中包含5个元素。
2. 一维数组的引用
数组定义后，可以引用其中的数组元素，引用方式为“数组标识符[下标]”。
**注意**
数组下标可以是整型常量或整型表达式。在数组iArray[4]中，只能使用iArray[0]、iArray[1]、iArray[2]、iArray[3]，而不能使用iArray[4]。若使用iArray[4]，则会出现下标越界错误。
### 8.1.2 一维数组的初始化
有3种方法：
1. 定义数组时直接对数组元素赋初值(数组元素值放在一对大括号中)。例如，
```c
int i,iArray[6]={1,2,3,4,5,6};
```
2. 如果只给一部分数组元素赋值，则未赋值的元素默认为被赋值0.例如，
```c
int iArray[6]={0,1,2};
```
数组iArray包含6个元素，但初始化只给了3个值，结果是数组前3个元素得到赋值，后3个元素默认赋值为0。
3. 当对全部数组元素都赋初值时，可以不指定数组长度。例如，
```C
int iArray[]={1,2,3,4};
```
上述代码的大括号中有4个元素，因此系统会默认为该数组变量的长度为4。

## 8.2 二维数组
### 8.2.1 二维数组的定义和引用
1. 二维数组的定义
二维数组可以看作是特殊的一维数组，其各个元素仍然是一组数组。其定义形式如下：
```C
数据类型 数组名[常量表达式1][常量表达式2];
```
常量表达式1定义了二维数组的行数，常量表达式2定义了二维数组的列数。
2. 二维数组的引用
二维数组元素的引用形式为“数组名[下标][下标]”。例如，array[1][2]表示对array数组的第2行第3个元素进行引用。
和一维数组一样，二维数组也要注意下标越界的问题。例如，
```C
int array[2][4];
……               /*对数组元素进行赋值*/
array[2][4]=9;  /*错误，下标越界*/
```
### 8.2.2 二维数组的初始化
二维数组赋初值，有以下4种情况。
1. 将所有数据写在大括号内，按照数组元素排列顺序对元素赋值。例如，
```C
int array[2][2]={1,2,3,4};
```
如果大括号内的数据少于数组元素的个数，则系统会默认后面未被赋值的元素值为0。
2. 为所有元素赋值时，可以省略行下标，但不能省略列下标。例如，
```C
int a[][3] = {1,2,3,4,5,6};
```
系统会根据数据的个数进行分配，一共有6个数据，而数组分为3列，因此数组有2行。
3. 分行给数组元素赋值。例如，
```C
int a[2][3]={{1,2,3},{4,5,6}};
```
在分行赋值时，可以只对部分元素赋值。例如，下面的代码种，a[0][0]的值是1；a[0][1]的值是2；
4. 直接对数组元素赋值。例如
```C
int a[2][3];
a[0][0]=1;
a[0][1]=2;
```
例，魔法阵数据
一个3x3的网格，将1~9的数字放如方格中(矩阵中心元素为5)，使得每行、每列以及每条对角线上的3个数相加都相同。通过键盘为二维数组元素赋值，并显示二维数组。
```C
#include<stdio.h>
int main()
{
  int a[3][3];  /*定义二维数组*/
  int i,j;  /*定义循环控制变量*/
  for(i=0;i<3;j++){
    printf("a[%d][%d]=",i,j);
    scanf("%d",&a[i][j]);
  }
  printf("输出二维数组\n"); /*信息提示*/
  for(i=0;i<3;j++){
    for(j=0;j<3;j++){
      printf("%d\t",a[1][j]); /*使用制表符控制间距，可排列更整齐*/
    }
    printf("\n"); /*使数据元素分行显示*/
  }
  return 0;
}
```
### 8.3 字符数组
数组中的元素类型为字符型时，称为字符数组。字符数组中的每个元素可以存放一个字符。字符数组的定义和引用方法与其他数据类型相似。
### 8.3.1 字符数组的定义和引用
1. 字符数组的定义
字符数组的定义形式如下：

char 数组标识符[常量表达式]

例如，下述代码定义了一个字符数组cArray，该数组中包含5个字符型的变量元素。
```C
char cArray[5];
```
2. 字符数组的引用
字符数组的引用也采用下标的形式。例如，引用数组cArray中的元素，并依次赋值，代码如下：
```C
cArray[0]='H';
cArray[1]='e';
cArray[2]='l';
cArray[3]='l';
cArray[4]='o';
```
### 8.3.2 字符数组的初始化
在对字符数组进行初始化操作时，有以下几种方法。
1. 逐个字符赋给数组中的元素。例如，
```C
char cArray[5]={'H','e','l','l','o'};
```
定义了一个包含5个元素的字符数组，在初始化的大括号中，每个字符赋值给一个数组元素。
2. 定义字符数组的同时进行初始化，此时可以省略数组的长度。
如果初值个数与预定的数组长度相同，在定义时可以省略数组长度，系统会自动根据初值个数来确定数组长度。例如，上面初始化字符数组的代码可以写成：
```C
char cArrary[]={"Hello"};
```
或者将“{}”去掉，写成：
```C
char cArrary[]="Hello";
```
### 8.3.3 字符数组的结束标志
在C语言中，使用字符数组保存字符串时，系统会自动为其添加“\0”作为结束符。也就是说，用字符串方式赋值比用字符逐个赋值要多占一个字节，多占的这个字节用于存放字符串结束标志“\0”。
例如，使用下列代码可以初始化一个字符数组：
```C
char cArray[]="Hello";
```
| H | e | l | l | o | \0 |

“\0”是由C编译系统自动加上的。因此上面的赋值语句等价于：
```C
char cArray[]={'H','e','l','l','o','\0'};
```
**注意**
如果在一个字符数组中先后存放多个不同长度的字符串，则应使数组长度大于最长的那个字符串的长度。

### 8.3.4 字符数组的输入和输出
字符数组的输入和输出可以使用两种格式字符：“%c”和“%s”。
使用格式字符“%c”可实现数组中字符的逐个输入与输入。例如，
```C
for(i=0;i<5;i++){
  printf("%c",cArray[i]);
}
```
使用格式字符“%s”可将整个字符串输入或输出。例如，
```C
char cArray[]="GoodDay!";
printf("%s",cArray);
```
使用格式字符“%s”输出字符串时，需注意：
+ 输出字符中不包括结束符“\0”
+ printf函数中的输出项是字符数组名cArray，而不是数组中的元素名cArray[0]等。
+ 即使数组长度大于字符串实际长度，也只会输出到“\0”为止
+ 如果一个字符数组中包含多个“\0”结束字符，则在遇到第一个“\0”时输出就结束。

## 8.4 多维数组
多维数组的声明和二维数组相同，只是下标更多。其一般形式如下：
```c
数据类型 数组名[常量表达式1][常量表达式2]……[常量表达式n];
```
## 8.5 数组的排序算法
选择法排序的原理如下：每次在待排数组中查找最大或最小的数组元素，将其值与最前面没有进行过排序的数组元素的值呼唤。这里，由大到小排序应查找最大值，由小到大排序则应查找最小值。
下面以数字9、6、15、4、2为例，利用选择法使其从小到大排序，每次交换后的数字顺序如表8.2所示。
| 排序过程 | 元素【0】 | 元素【1】 | 元素【2】 | 元素【3】 | 元素【4】 |
| --- | --- | ---- | --- | --- | --- |
| 起始值 | 9 | 6 | 15 | 4 | 2 |
| 第1次 | 2 | 6 | 15 | 4 | 9 |
| 第2次 | 2 | 4 | 15 | 6 | 9 |
| 第3次 | 2 | 4 | 6 | 15 | 9 |
| 第4次 | 2 | 4 | 6 | 9 | 15 |
| 第5次 | 2 | 4 | 6 | 9 | 15 |

选择法从小到大排序
```C
#include<stdio.h>
int main()
{
  int i,j;
  int a[10];  /*定义数组，存储用户输入的10个数*/
  int iTemp;  /*定义变量，表示最小的数组元素*/
  int iPos; /*定义变量，表示元素位置*/
  printf("为数组元素赋值:\n");
  for(i=0;i<10;i++){  // 输入10个数，为数组元素赋值
    printf("a[%d]=",i);
    scanf("%d",&a[i]);
  }
  
  /*使用选择法对数组元素从小到大排序*/
  for(i=0;i<9;i++){ /*设置外层循环下标0~8，表示前9个数组元素*/
    iTemp=a[i]; // 假设当前元素为最小值
    iPos=i; //记录最小元素位置
    for(j=i+1;j<10;j++){ //设置内层循环下标为i+1~9，表示剩下的未排序数组元素部分
      if(a[j]<iTemp){
        iTemp = a[j]; //重新设置最小值
        iPos = j;   // 修正最小元素位置
      }
    }
  }
  printf("排序结果如下：\n");
  for(i=0;i<10; i++){
    printf("%d\t",a[i]);
    if(i==4){
      printf("\n");
    }
    printf("\n");
    return 0;
  }
}
```
### 8.5.2 冒泡排序
………………………………………………………………………………………………………………………………………………
………………………………………………………………………………………………………………………………………………
………………………………………………………………………………………………………………………………………………
### 8.5.3 交换法排序
………………………………………………………………………………………………………………………………………………
………………………………………………………………………………………………………………………………………………
………………………………………………………………………………………………………………………………………………
### 8.5.4 插入法排序
………………………………………………………………………………………………………………………………………………
………………………………………………………………………………………………………………………………………………
………………………………………………………………………………………………………………………………………………
### 8.5.5 折半法排序
………………………………………………………………………………………………………………………………………………
………………………………………………………………………………………………………………………………………………
………………………………………………………………………………………………………………………………………………
### 8.5.6 排序算法的比较
………………………………………………………………………………………………………………………………………………
………………………………………………………………………………………………………………………………………………
………………………………………………………………………………………………………………………………………………
# 第9章 函数
## 9.1 函数概述
没给C程序的入口和出口都位于main函数中，但并不需要把所有指令都放在main函数中。一般的做法是将程序划分成若干模块，每个模块完成一部分功能，不同的程序模块可以有不同的人来完成，从而提高软件开发的效率。
主函数可以调用其他函数，其他函数间也可以相互调用。函数可以有参数和返回值，通过它们实现数据间的传递。在主函数中调用其他函数，这些函数执行完毕之后会返回main函数中。通常把这些被调用函数称之为下层函数。函数调用发生时，立即执行被调用的函数，而调用者则进入等待的状态，直到被调用函数执行完毕。

+ 编写3个函数：做饭，钓鱼，写诗
在本实例中，定义3个函数来完成做饭、钓鱼、写诗等特定的功能，然后在主函数中调用它们。
为了简化函数的功能，这里只让其输出一条提示信息。读者可通过本实例对函数有一个直观的认识。
```C
#include<stdio.h>
void Cood();  // 声明Cook函数
void Fish();  // 声明Fish函数
void Poem();  // 声明Poem函数
int main()
{
  Cook(); //调用Cook函数
  Fish(); //调用Fish函数
  Poem(); //调用Poem函数
  return 0;
}
void Cook(){  //自定义Cook函数
  printf("会做饭\n");
}
void Fish(){  //自定义Fish函数
  printf("会钓鱼\n");
}
void Poem(){  //自定义Poem函数
printf("会写诗\n");
}
```
在分析本实例之前，我们先来了解以下什么是C程序源文件、库函数和用户自定义函数。
+ 源文件：由一个或者多个函数组成。C语言以源程序为单位进行编译，，而不是以函数为单位进行编译。
+ 库函数：由C语言系统提供，用户无须定义，调用前也不必做类型说明，但需要在程序开始部分包含有该函数原型的头文件。例如，要使用字符串操作函数strlen、strcmp等时，需在程序开始时包string.h头文件。
+ 用户自定义函数：用户编写的用来实现特定功能的函数。例如，Cook、Fish和Poem函数都是自定义函数。

## 9.2 函数的定义和声明
C语言的库函数可以直接调用，如printf输出函数。而自定义函数则必须由用户进行定义，确定其要实现的功能，这样才能被其他函数调用。
### 9.2.1 函数的定义
一个函数应包括函数头和函数体。定义一个函数的的语法格式如下:
```C
返回值类型 函数名(参数列表){
  函数体 //函数实现特定功能的过程
}
```
1. 函数头
函数头是函数的入口，标志着一段函数代码的开始。函数头包括返回值类型、函数名和参数列表3个部分，
+ 返回值类型：函数返回值的类型，必须是C语言中的某个数据类型。这里函数的返回值将是一个int型值。
+ 函数名：函数的标识符，在一个C程序中应保持唯一。因为是标识符，所以函数名要遵守标识符命名规则。这里，函数名是AddTwoNumber，可以推测处该函数的功能是两数相加求和。
+ 参数列表：调用函数时，用于将主调用函数中的实际参数复制到该列表对应的形式参数中。可以没有参数，也可以有多个参数。这里定义了两个int变量，表示要相加的两个数。
2. 函数体
函数体位于函数头的下方位置，有一对大括号括起来，大括号巨顶了函数体的范围。函数要实现的特定功能，都是在函数体部分通过代码语句完成的，最后通过return语句返回实现的结果。
在上面的代码中，函数体内首先定义了一个int型变量，用来保存加法的计算结果，之后利用传递进来的参数进行加法操作，并将结果保存在result变量中，最后函数要将所得到的结果进行返回。通过这些语句的操作，实现了求解两数和的特定功能。
在定义函数时会出现以下几种特殊的情况。
+ 无参函数：没有参数列表的函数。
+ 空函数：没有任何内容，也没有什么实际功能的函数。空函数的形式如下：
```C
类型说明符 函数名(){

}
```
### 9.2.2 函数的声明
在程序中编写函数时，要先对函数进行声明，再对函数进行定义。函数定义是为了让编译器知道函数的功能，而函数声明是为了让编译器预先知道有这么一个函数，以及函数的名称、参数、返回值类型等的信息。
函数声明的一般形式如下：
```C
返回值类型 函数名(参数列表);
```
**注意**
函数声明语句的最后要用分号“;”作为结尾。例如，
```C
#include<stdio.h>
void exchange(int a,int b); //声明exchange函数
int main()
{
  int a=3,b=4;
  printf("交换之前的值a=%d,b=%d\n",a,b);
  exchange(a,b);    //调用exchange函数
  return 0;
}
void exchange(int a, int b) // 定义exchange函数，用于交换两个数
{
  int c;
  c = a;
  a = b;
  b = c;
  printf("交换后的值a=%d,b=%d\n",a,b);
}
```
**注意**
如果先定义函数，再调用函数，则不再需要进行函数声明，此时函数定义已包含了函数声明的作用。

## 9.3 函数参数
### 9.3.1 形式参数与实际参数
函数的参数分为两种：形式参数和实际参数。
1. 形式参数
**声明和定义**函数数时，函数名**后面括号**中的参数称为形式参数。这些参数只是定义了类型，在实际参数传入前并没有实际意义，因此叫做形式参数，简称形参。
2. 实际参数
调用函数时，函数名后面括号中的参数称为实际参数。调用函数的过程就是真正使用这个函数的过程，此时调用者会传递一些要实际参与运算的参数给被调用函数，这些实际参与运算的参数就是实际参数，简称实参。
**注意**
函数参数可以是常量、变量、数组、指针等，也可以是表达式。

### 9.3.2 数组作函数参数
1. 数组元素作为函数参数
数组元素作为函数实参，与普通变量作为函数实参一样，是单向的值传递。
定义一个数组并为其赋值，然后将数组元素作为函数实参进行传递。自定义函数体中，形参得到实参传递的数值后，将其显示输出。
```C
#include<stdio.h>
void ShowMember(int iMember);   //声明ShowMember函数，形参为一个整型

int main()
{
  int iCoun[10];
  int i;
  for(i=0;i<10;i++){
    iCount[i]=i;
  }
  for(i=0;i<10;i++){
    ShowMember(iCount[i]);
  }
  return 0;
}

void ShowMember(int iMember){   //自定义ShowMember函数，形参为一个整型数
  printf("Show the member is%d\n",iMember);
}
```
2. 数组名作为函数参数
C语言中，数组名表示的是数组中第一个元素的地址。因此当数组名作为函数参数时，传递的是数组的地址。这点和数组元素做实参是不一样的。

3. 可变长度数组作为函数参数
数组作为函数参数时，如果未指明数组大小，就属于长度可变的数组作为函数参数。
```C
#include<stdio.h>
void _strcat(char str1[],char str[2]){    //自定义strcat函数，形参为两个长度可变的数组
  int i,j;
  for(i=0;str1[j]!='\0';j++){   // 字符数组1中循环
    for(j=0;str2[j]!='\0';j++){
      str1[i+j]=str2[j]; 
    }
      str1[i+j]='\0'; // 结束
  }
}
int main()  // 主函数main
{
  char str1[100],str2[100]; // 定义字符数组
  printf("请输入字符串1：\n"); // 提示信息
  gets(str1);   // 输入字符串1
  printf("请输入字符串2：\n");   // 提示信息
  gets(str2);   //输入字符串2
  _strcat(str1,str2); // 调用函数连接2个字符串
  printf("连接之后的字符串是：%s\n",str1);  //显示连接后的字符串
  return 0;
}
```

## 9.4 函数的调用和返回
### 9.4.1 函数的调用
函数的调用方式有3种，包括语句调用、表达式调用和函数参数调用。
1. 语句调用
函数调用作为在一个独立语句出现，就称为语句调用。返回值可有可无。例，
```C
Display();
```
2. 表达式调用
当函数调用出现在一个表达式中时，函数必须返回一个确定的值，作为表达式运算的一部分。例，
```C
iResult=iNum3*AddTwoNum(3,5);
```
3. 函数参数调用
函数调用还可以出现在函数参数中。此时，函数的返回值将作为参数使用。例如：
```C
iResult=AddTwoNum(10,AddTwoNum(3,5));
```
### 9.4.2 函数的返回
在函数体中常看到一条return语句。
```C
return 0;
```
这就是返回语句。return语句的作用有**两个**。
1. 退出函数，返回主调程序中
C程序中，有两种方法可以终止函数执行，返回到调用函数位置。
+ 函数体中的所有语句都已执行完毕，遇到结束符号“}”后自动返回。
+ 遇到return语句，随即返回。
2. 返回一个值，供主调函数使用
用户调用函数时，通常是希望得到一个确定的返回值。该返回值是通过return语句实现的。
返回值也需要**约定**类型，因此定义函数时，需要明确指定函数返回值的类型。例如，
```C
int Max(int iNum1, int iNum2);    // 函数返回值类型为int
double Min(double dNum1, double dNum2);   // 函数返回值类型为double
char Show(char cChar);    // 函数返回值类型为char
```
若函数返回值的类型和return语句中表达式的值**不一致**，则**以函数返回值的类型为准**。数值型数据可以自动进行类型转换，即函数定义的返回值类型决定最终返回值的类型。
**注意**
return语句后面的括号可以省略，即return 0和return(0)是相同的。另外，函数也可以没有返回值。例如，返回值类型为void的函数就没有返回值。
### 9.4.3 函数的嵌套调用
C语言虽然不允许进行函数嵌套定义，但却可以函数嵌套**调用**，即可在一个函数体内可以调用另外一个函数。
### 9.4.4 函数的递归调用
所谓递归调用，就是函数自己调用自己。从定义中可以看出，函数递归调用是函数嵌套调用的一种特殊形式。
函数可以直接调用自己，也可以间接调用自己。
所谓间接调用，就是在递归函数的下层函数中调用自己。
递归之所以能实现，是因为函数的每个执行过程在栈中都有自己的形参和局部变量副本，这些副本和该函数的其他执行过程不发生关系。这种机制是当代大多数程序设计语言实现子程序结构的基础。
## 9.5 内部函数和外部函数
函数是C程序中的最小单位，可以把一个或多个函数保存为一个文件，这个文件就被称为源文件。当一个源程序由多个源文件组成时，多个文件之间的函数可以相互调用。也可通过设置为内部函数，禁止其被其他文件调用。因此，根据能不能被其他文件调用，C语言又把函数分为两种：一类是内部函数，另一类是外部函数。
### 9.5.1 内部函数
第一个内部函数，如果该函数只能被所在的源文件使用，那么就称这样的函数为内部函数。内部函数又称为静态函数。
使用内部函数，可以使函数只局限在函数所在的源文件中，如果在不同的源文件中有同名的内部函数，则这些同名函数间是互不干扰的。
定义内部函数时，要在函数返回值和函数名前面加上关键字static进行修饰。一般形式如下：
```C
static 返回值类型 函数名(参数列表);
```
例如，定义一个功能为加法运算且返回值是int型的内部函数，代码如下：
```C
static int Add(int iNum1, int iNum2);
```
在函数的返回值类型int前加上关键字static，可将原来的函数指定成内部函数。

### 9.5.2 外部函数
外部函数是可以被其他源文件调用的函数。定义外部函数时，使用关键字extern进行修饰。同样使用外部函数时，要先使用extern声明所用的函数是外部函数。例如，
```C
extern int Add(int iNum1, int iNum2);
```
**注意**
C语言中，定义函数时如果未指明是内部函数还是外部函数，系统将默认此函数为外部函数。也就是说，定义外部函数时可以省略关键字extern。

## 9.6 局部变量和全局变量
### 9.6.1 局部变量
在函数内部定义的变量是局部变量。函数的形式参数也属于局部变量，作用范围仅限于函数内部的所有语句块。
**说明**
在语句块内声明的变量仅在该语句内部起作用，当然也包括嵌套在其中的子语句块。
C语言中，位于不同作用域的变量可以使用相同的标识符，也就是变量名可以相同。如果内层作用域中定义的变量和已经声明的某个外层作用域中的变量有相同名称，内层作用域中的变量将屏蔽外层作用域中的同名变量，知道结束内层作用域为止。这就是局部变量的屏蔽作用。
### 9.6.2 全局变量
函数中定义的变量都是局部变量。如果一个变量在所有函数外部声明，这个变量就是全局变量。顾名思义，全局变量可以在程序的任何位置进行访问。
**注意**
全局变量不属于某个函数，而属于整个源文件。如果外部文件要访问它，则要用extern关键字进行引用修饰。
全局变量可增加函数间的数据联系。同一文件中的所有函数都能引用全局变量的值，因此如果在一个函数中改变了全局变量的值，就能影响到其他函数，相当于各个函数间有了一个直接传递通道。

## 9.7 函数应用
编译系统通常会提供一些标准库函数，以供用户快速调用。不同的编译系统，提供的库函数会略有差距。下面介绍ANSI C提供的部分成勇的库函数。
### 9.7.1 数学函数
**注意**，使用数学函数时，要包含math.h头函数，即要在程序开始处添加#include<math.h>。
1. abs函数
abs函数的功能是求解**整数的**绝对值。如：
```C
int abs(int i);
```
2. labs函数
labs函数的功能是求解**长整型数**的绝对值。函数形式如下：
```C
long labs(long n);
```
3. fabs函数
功能是求解实型数的绝对值。函数形式如下：
```C
double fabs(double x);
```
4. sin函数
功能：求解正弦。函数形式如下：
```C
double sin(double x);
```
例如，求一个角正弦值的代码如下：
```C
double fResultSin;  // 定义实型变量
double fXsin = 0.5;   // 定义实型变量，为其赋值为0.5
fResultSin = sin(fXsin);    // 使用正弦函数
```
5. cos函数
功能：求解**余弦**。函数形式如下：
```C
double cos(double x);
```
6. tan函数
功能：求解**正切**。函数形式如下：
```C
dobule tan(double x);
```
### 9.7.2 字符函数
使用时哟啊先包含头文件ctype.h。
1. isalpha函数
isalpha函数的功能是检测某个字符是否是字母，如果是字母表中的字母(大写或小写)，则返回非0值，否则返回0。函数形式如下：
```C
int isalpha(int ch);
```
例如，判断输入的字符是否为字母的代码如下：
```C
char c; // 定义字符变量
scanf("%c",&c);   // 输入字符
isalpha(c);   调用isalpha函数判断输入的字符
```
2. isdigit函数
isdigit函数的功能是检测某个字符是否是数字，如果是数字，则函数返回非0值，否则返回0。函数形式如下：
```C
int isdigit(int ch);
```
3. isalnum函数
isalnum函数的功能是检测某个字符是否是字母或数字，如果是字母表中的某个字母或某个数字，则函数返回非0值，否则返回0。函数形式如下：
```C
int isalnum(int ch);
```
### 9.7.3 字符串处理函数
编写程序时，经常要对字符和字符串进行操作，如转换字符大小写、求字符串长度等，这些都可以使用字符串函数来解决。字符串处理函数，使用时要先包含头文件string.h。
1. strcpy函数
strcpy函数在字符串函处理函数中，strcpy函数用于复制特定长度的字符串到另一个字符串中。其语法格式如下：
```C
strcpy(字符数组1, 字符数组2);
```
功能：把字符数组2中的字符串复制到字符数组1中，字符串结束标志“\0”也一同复制。复制过去的内容将覆盖字符数组1中的对应内容。
**说明**
(1)字符数组1要有足够的长度，否则无法装下待复制的字符串。
(2)“字符数组1”必须写成**数组名形式**；而“字符数组2”可以是数组名，也可以是一个字符串常量，这时相当于把一个字符串赋予该字符数组。
(3)不能用赋值语句将一个字符串常量或字符数组直接赋给一个字符数组。
照葫芦画瓢
```C
#include<stdio.h>
#include<string.h>  // 包含头文件string.h

int main()
{
  char str1[30],str[30];
  printf("输入目标字符：\n");
  gets(str1); // 输入目标字符
  printf("输入源字符串：\n");
  gets(str2); // 输入源字符串
  printf("输出目标字符串：\n");
  puts(str1); // 输出目标字符串
  printf("输出源字符串：\n");
  puts(str2); // 输出目标字符串
  strcpy(str1, str2);   // 调用strcpy函数实现字符串复制
  printf("调用strcpy函数进行字符串复制：\n");
  printf("调用字符串之后的目标字符串：\n");
  puts(str1);   // 输出复制后的目的字符串
  return 0;
}
```
2. strcat函数
字符串连接就是将一个字符串连接到另一个字符串的末尾，使其组合成一个新的字符串。strcat函数就是具有字符串连接的功能，其语法格式如下：
```C
strcat(字符数组1, 字符数组2);
```
功能：把字符数组2中的字符串连接到字符数组1的字符串后面，并删去字符数组1中原有的串**结束标志**“\0”。
**说明**
字符数组1应有足够的长度，以保证能装下连接后的字符串。
**说明**
字符串复制实质上是用字符数组2中的字符串覆盖字符数组1中的字符串，而字符串连接则不存在覆盖问题，只是单纯地将字符数组2中的字符串连接到字符数组1中字符串的后面。
3. strcmp函数
字符串比较就是将一个字符串与另一个字符串从首字母开始，按照ASCII码的顺序逐个进行比较。strcmp函数具有在字符串间进行比较的功能，其语法格式如下：
```C
strcmp(字符数组1, 字符数组2);
```
功能：按照ASCII码顺序比较两个数组中的字符串，并返回结果。两个字符串比较时，若出现不同的字符，则以第一个不同字符的比较结果作为整个比较的结果。返回值如下：
+ 字符串1=字符串2，返回值为0。
+ 字符串1>字符串2，返回值为正数。
+ 字符串1<字符串2，返回值为负数。

**注意**
字符串比较不能使用关系运算符，也不能使用赋值运算符。因此，下面的语句是错误的：
if(str[2]==mingri)……
  str[2]=mingri……

4. strupr函数和strlwr函数
字符串的大小写转换需要使用strupr和strlwr函数。strupr函数的语法格式如下：
```C
strupr(字符数组名);
```
功能：将数组中存放的字符串的小写字母转换成大写字母，其他字母不变。
strlwr函数的语法格式如下：
```C
strlwr(字符数组名);
```
功能：将数组中存放的字符串的大写字母转换成小写字母，其他字母不变。
5. strlen函数
有时需要知道字符串的长度，虽然通过循环判断字符串结束标志“\0”也能获得字符串的长度，但毕竟实现起来相对繁琐。
strlen函数的语法格式如下：
```C
strlen(字符数组名);
```
功能：计算数组中存放的字符串的实际长度(不包含字符串结束标志“\0”)。

# 第10章 指针
## 10.1 指针的相关概念
### 10.1.1 地址与指针
要想弄明白什么是指针，就必须弄清楚数据在内存中是如何存储的，又是如何被读取的。

### 10.1.3 指针变量
一个变量的地址称为该变量的指针。如果有一个变量专门用来存放另一个变量的地址，它就是指针变量。在C语言中有专门用来存放内存单元地址的变量类型，即指针类型。
1. 指针变量的定义
```C
类型说明 * 变量名
```
其中，“*”表示该变量是一个指针变量，“变量名”即为定义的指针变量名，“类型说明”表示指针变量所指向的变量的数据类型。
2. 指针变量的赋值
指针变量同普通变量一样，使用前需要先进行定义并赋予具体的值。未经赋值的指针变量不能使用。与其他变量赋值不同，给指针变量赋值只能赋予地址，而不能是其他数据，否则将引起错误。C语言一般用“& 变量名”表示某个变量的地址，如&a表示变量a的地址，&b表示变量b的地址。
给一个指针变量赋值可以有以下两种方法。
（1）定义指针变量的同时进行赋值。例如，
```C
int a;
int * p = &a;
```
（2）先定义指针变量，之后再赋值。例如，
```C
int a;
int *p;
p = &a;
```

**注意**
注意着两种赋值语句的区别。如果先定义指针变量之后再赋值，赋值时指针变量前不再加“*”。

3. 指针变量的引用
引用指针变量是对变量进行间接访问的一种形式。引用指针变量的形式为“*指针变量”，其含义是引用指针变量所指向的值。

**误区警示**
没有初始化的指针变量俗称“野指针”，使用时容易产生错误（导致不合法的内存空间）。良好的编程习惯是在定义指针变量时就将其初始化为NULL，由于NULL处禁止吸入，所以一旦有错误，可以将错误造成的危害降到最小。

使用指针比较两个数的大小，
```C
#include<stdio.h>
int main()
{
	int a=10,b=11;		//定义两个整型变量并初始化 
	int *ipointer1,*ipointer2;		// 定义两个整型指针变量
	ipointer1=&a;		// 将地址赋给指针变量
	ipointer2=&b;
	if(*ipointer1>*ipointer2)		// 使用指针比较两数大小
		printf("a的值大\n");
	else
		printf("b的值大\n");
	return 0;
}
```

4. “&”和“`*`”运算符

运算符“&”和“`*`”都是单目运算符。“&”是取地址运算符，用于返回一个操作数的地址。“`*`”是指针运算符，用于返回指定地址内保存的变量值。
例如，“p=&i;”是将变量i的内存地址赋给指针变量p。“q= * p;” 是将指针p指向的变量，即i的值赋给q，假如变量i的值是5，则q的值也是5。
5. “&* ”和“* &”的区别

下面通过两条语句来分析“&* ”和“* &”运算的区别。如下，
```C
int a;
p=&a;
```
因为“&”和“* ” 的优先级相同，按自右向左的方向结合，因此“&* p”先进行“* ”运算，“* p”相当于变量a；再进行“&”运算，“&* p”就相当于取变量a的地址。“* &a”先进行“&”运算，“&a”就是取变量a的地址，然后执行发“* ”运算，“* &a”就相当于变量a所在地址的值，实际就是变量a。

### 10.1.4 指针的自增、自减运算
指针的自增自减运算不同于普通变量的自增自减运算，也就是说，并非简单地加1减1，而是按照它所指向的数据类型的直接长度进行增减。例，
输出整型变量地址
```C
#include<stdio.h>
main()
{
	int i;
	int *p;
	printf("please input the number:\n");
	scanf("%d",&i);		//输入一个整型数
	p=&i；	// 将整型变量i的地址赋给指针变量
	printf("the result is:%d\n",p);
	p++;	//指针自增，地址加1，即增加4个字节
	printf("the result2 is:%d\n",p);
}
```

## 10.2 数组与指针
使用数组时，系统需要提供一段连续的内存来存储数组中的各元素，如果把数组的地址赋给指针变量，就可以通过指针变量来引用数组。

### 10.2.1 一维数组与指针
定义一维数组时，系统会在内存中为其分配一段存储空间，数组名就是数组在内存中的首地址。若再定义一个指针变量，并将数组的首地址传给指针变量，则该指针变量，则该指针就指向了这个一维数组。例如：
```C
int *p,a[1];
p=a;
```
这里a是数组名，也就是数组的首地址，将它赋给指针变量p，也就是将数组a的首地址赋给p。也可以写成如下形式：
```C
int *p,a[10];
p=&a[10];
```
上面的语句是将数组a中首个元素的地址赋给指针变量p。由于a[0]的地址就是数组的首地址，因此上述两条赋值语句的操作效果完全相同。

输出100以内开始5个数和后5个数
定义两个指针变量，再定义两个一维数组，将两个数组元素分别赋给两个指针。利用for循环输入两个数组的值(100以内开始5个数和后5个数)，再用for循环和指针输出数组值。代码如下：
```C
#include<stdio.h>
void main()
{
	int *p,*q,a[5],b[5],i;		// 定义变量
	p=&a[0];		// 将数组首地址赋给指针
	q=b;
	printf("please input arrary a:\n");		//提示输入数组a
	for(i=0; i<5; i++)		// 利用&a[i]形式输入数组a
		scanf("%d",&a[i]);
	printf("please input array b:\n");		//提示输出数组b元素
	for(i=0; i<5; i++)		// 利用&b[i]形式输入数组b
		scanf("%d",&b[i]);
	printf("array a is:\n");		// 提示输出数组a元素
	for(i=0; i<5; i++)
		printf("%5d",*(p+i));		// 利用*(p+i)形式输出数组a
	printf("\n");
	printf("array b is:\n");		// 提示输出数组b
	for(i=0; i<5; i++)
		printf("%5d", *(q+i));		// 利用*(q+i)形式输出数组b
	printf("\n");
}
```

如下两条语句，都表示将数组首地址赋给指针变量。
```C
p=&a[10];
q=b;
```
+ p+n与a+n都用于表示数组元素a[n]的地址，即&a[n]。对整个a数组来说，共有5个元素，n的取值为`0~4`，则数组元素的地址就可以表示为`p+0~p+4或a+0~a+4`。
+ `*(p+n)`和`*(a+n)`都用于表示数组元素a[n]。语句“printf("%5d",`*`(p+i);”和“printf("%5d",`*`(q+i));”表示输出数组a、b中对应的元素。


### 10.2.2 二维数组与指针
对于一个m行n列的二维数组，其元素地址的表示方法如下：
+ a表示二维数组的首地址，也表示数组第1行的首地址，a+1表示第2行的首地址，a+m表示第m+1行的首地址。
+ a[0]+m表示数组第1行第n+1个元素的地址，a[m]+n表示第m+1行第n+1个元素的地址。
+ &a[0]表示数组第1行的首地址，&a[m]表示第m+1行的首地址。
+ &a[0][0]既可以表示数组第1行1列的首地址，也可以看作整个数组的首地址。&a[m][n]就是第m+1行n+1列元素的地址。

指针也可表示地址，因此通过指针可以引用二维数组中的元素
+ `*(*(a+m)+n)`和`*(a[m]+n)`含义相同，都表示数组第m+1行第n+1列元素。

### 10.2.3 字符串与指针
可以通过两种方式访问一个字符串，一是使用字符数组，二是使用字符指针。例如，
使用指针输出字符串
利用字符型指针输出字符串“hello mingri”
```C
#include<stdio.h>
main()
{
	char* string = "hello mingri";
	printf("%s",string);	// 输出字符串
	
	return 0;
}
```
**注意**
这里并不是把“hello mingri”中的所有字符存放到string中，只是把该字符串中第一个字符的地址赋给指针变量string。

### 10.2.4 指针数组
字符串数组有别于字符数组。字符数组是一个一维数组，而字符串数组是以字符串作为数组元素的数组，可以将其看成一个二维字符数组。例如，
一个简单的字符串数组：
```C
char country[5][20]={ "China", "Japan", "Russia", "Germany", "Switzerland" };
```
上述代码中，字符型数组变量country被定义为含有5个字符串的数组，每个字符串的长度都必须小于20(这里要考虑字符串最后的“\0”)。

通过上述代码发现，有些字符串的长度不够20字节的空间，较为浪费。解决此问题，可以使用指针数组，使每个指针指向所需要的字符常量。此方法需要在数组中保存字符指针，虽然也占用空间，但要远少于字符串数组占用的空间。

一个数组，如果其元素均为指针类型数据，则该数组称为指针数组。也就是说，指针数组中的每一个元素都相当于一个指针变量。一维指针数组的定义形式如下：
```C
类型名 数组名[数组长度];
```

## 10.3 指向指针的指针
一个指针可以指向整型变量、实型变量、字符型变量，当然也可以指向另一个指针，此时称其为指向指针的指针。定义如下：
```C
类型标识符 **指针变量名;
```

## 10.4 指针变量作函数参数
整型变量、实型变量、字符型变量、数组名和数组元素等均可作为函数参数。此外，指针型变量也可以作为函数参数，例如，
交换两个变量的值
用指针作函数参数，交换两个变量的值。在主函数中，调用自定义函数，利用指针将两个数交换，具体代码如下：
```C
#include<stdio.h>
void swap(int *a, int *b)
{
	int tmp;
	tmp = *a;
	*a = *b;
	*b = tmp;
}
main()
{
	int x, y;
	int *p_x, *p_y;
	printf("请输入两个数：\n");
	scanf("%d", &x);
	scanf("%d", &y);
	p_x = &x;
	p_y = &y;
	swap(p_x, p_y);
	printf("x=%d\n", x);
	printf("y=%d\n", y);
}
```

## 10.5 返回指针值的函数
指针变量也可以指向一个函数。函数在编译时会被分配一个入口地址，该入口地址就称为函数的指针。可以用一个指针变量指向函数，然后通过该指针变量调用此函数。
一个函数可以带回一个整型值、字符值、实型值等，也可以带回指针型的数据，即地址。其概念与之前介绍的类似，只是带回的值的类型是指针类型而已。返回指针值的函数简称为指针函数。
定义指针函数的一般形式如下：
```C
类型名 *函数名(参数列表);
```
下面的定义中，fun是函数名，调用它以后能得到一个指向整型数据的指针。x和y是函数fun的形式参数，这两个参数均为基本整型。函数名前面有一个“* ”，表示次函数是指针型函数。类型说明是int，表示返回的指针指向整型变量。
```C
int *fun(int x, int y);
```

## 10.6 指针数组作main函数的参数
main函数是运行所有程序的入口，由系统调用。当处于操作命令状态下，输入main所在的文件名，系统即调用main函数。
main的函数一般是没有参数的。但实际上，main函数也可以是有参函数，其带参形式如下：
```C
main(int argc, char *argv[])
```
有两个参数，一个整型和一个指针数组。当一个C源程序经过编译、链接后，会生成扩展名为.exe的可执行文件，该文件可直接在操作系统下运行。对于main函数来说，其实际参数和命令是一起给出的，也就是一个命令行包括命令名和需要传给main函数的参数。命令行的一般形式如下：
```C
命令名 参数1 参数2 …… 参数n
```
其中，“命令名”就是可执行文件的文件名，命令名和其后参数之间须用空格分隔。
命令行与main函数的参数间存在一定关系。假设命令行为：
```C
file1 happy bright glad
```
这里，file1为文件名，就是file1.c经编译、链接后生成的可执行文件file1.exe，气候跟3个参数。以上命令行与main函数中的形式参数关系如下：参数argc记录了命令行中命令与参数的个数，这里包括file1、happy、bright和glad，共4个，指针数组的大小由参数的值决定，这里为char * argv[4]。
利用指针数组作main函数的形参，可以向程序传送命令行参数。
**说明**
参数字符串的长度是不定的，参数数量也是任意的，并不规定具体个数。

例：输出main函数的参数形式
```C
#include<stdio.h>
main(int argc, char * argv[])		// main函数为带参函数
{
	printf("the list of parameter:\n");
	printf("命令名：\n");
	printf("%s\n", *argv);
	printf("参数个数：\n");
	printf("%d\n", argc);
}
```

# 第11章 结构体和共用体
迄今为止，我们在程序中用到的都是基本数据类型。但实际开发中，有时简单的变量类型无法满足程序中各种复杂的数据要求，因此C语言还提供了构造类型。构造类型数据是由基本类型数据按照一定规则组成的。
## 11.1 结构体
有时我们需要定义一些复杂的数据类型，它可能包含多个不同属性，每个属性需要用不同类型来表示。C语言中，可以把一些内在联系的不同变量组织起来，封装成一个整体，即定义成一个结构体(structure)，以此来表示一种新的数据类型。之后，即可以向处理基本数据类型那样，对结构体类型进行各种操作。
### 11.1.1 结构体类型的声明
结构体是一种构造类型，它由若干成员组成。其成员可以是一个基本数据类型，也可以是另一个构造类型。声明一个结构体的过程，就是创建一种新的类型名的过程。
声明结构体时使用的关键字是struct，其一般形式如下：
```C
struct 结构体名
{
	 成员列表
};
```
关键字struct表示声明的是一个结构体，“结构体名”表示要创建的新类型名，大括号中的“成员列表”包括构成该结构体的所有成员。注意，声明结构体是大括号后的分号“;”不能遗漏。例，
声明一般包括产品名称、形状、颜色、功能、价格和产地等属性，声明代码如下：
```C
struct Product		// 声明商品结构体
{
	char cName[10];		// 产品名称
	char cShape[20];		// 形状
	char cColor[10];		// 颜色
	char cFunc[20];		// 功能
	int iPrice;		// 价格
	char cArea[20];		// 产地
}
```

### 11.1.2 结构体变量的定义
声明万结构体后，就创建了一种新的类型名，后续就可以使用这种新的类型名定义变量。定义结构体变量的方式有如下3种。
(1) 先生们结构体类型，再定义变量。
例如，使用前面声明的Product结构体类型定义两个结构体变量product1和product2，代码如下：
```C
struct Proudct
{
	char cName[10];		// 产品名称
	char cShape[20];		// 形状
	char cColor[10];		// 颜色
	char cFunc[20];		// 功能
	int iPrice;		// 价格
	char cArea[20];		// 产地
};
struct Product product1;	// 定义结构体类型变量
struct Product product2;
```
struct Product是结构体类型名，而product1和product2是结构体变量名。既然都是使用Product类型定义的变量，那么 这两个变量就具有相同的结构。
**技巧**
在一些大型开发中，为了便于修改和使用，常常将结构体类型的声明放在一个头文件中，这样在其他源文件中如果需要使用该结构体类型，则可以用 #include命令将该头文件包含到源文件中。

定义一个基本类型的变量与定义一个结构体类型变量的不同之处在于：定义结构体变量不仅要求指定变量为结构体类型，而且要求指定为某一特定的结构体类型，如struct Product；而定义基本类型的变量时（如整型变量），只需要指定int型即可。
**说明**
定义结构体变量后，系统就会为其分配内存单元。例如，product1和product2在内存中各占84字节（10+20+10+20+4+20）。

(2) 声明结构类型的同时定义结构体变量。例如，
```C
struct Product
{
	char cName[10];		// 产品名称
	char cShape[20];		// 形状
	char cColor[10];		// 颜色
	int iPrice;		// 价格
	char cArea[20];		// 产地
} product1,product2 ;		// 定义结构体变量
```

(2) 直接定义结构体类型变量（此时不需要给出结构体名称）。例如，
```C
struct
{
	char cName[10];		// 产品名称
	char cShape[20];		// 形状
	char cColor[10];		// 颜色
	int iPrice;		// 价格
	char cArea[20];		// 产地
} product1,product2;		// 定义结构体变量
```
**注意**
类型与变量是不同的。例如，只能对变量进行赋值操作，不能对类型进行操作。

### 11.1.3 结构体变量的引用
定义了结构体类型变量以后，就可以引用该变量，引用形式“结构变量名.成员名”。例如，
```C
product1.cName="lcebox";
product1.iPrice=2000;
```
**注意**
不能直接将结构体变量作为一个整体进行输入和输出。

如果成员本身又属于一个结构体类型，就需要使用若干个成员运算符“.”找到最低一级的成员，对其进行赋值、存取以及运算操作。例如，对上面定义的student1变量中的出生日期进行赋值：
```C
student1.birthday.year=1986;
student1.birthday.month=12;
student1.birthday.day=6;
```
**注意**
不能使用student1.birthday访问student1变量中的成员birthday，因为birthday本身也是一个结构体变量。

结构体变量的成员可以像普通变量一样，进行各种运算。例如，
```C
product2.iPrice=Product1.iPrice+500;
product1.iPrice++;
```
因为“.”运算符的优先级最高，所以product1.iPrice++是product1.iPrice成员进行自加运算，而不是先对iPrice进行自加运算。
还可以对结构体变量成员的地址进行引用，也可以对结构体变量的地址进行引用，例如，
```C
scanf("%d", &product1.iPrice);		// 输入成员iPrice的值
printf("%o", &product1);		// 输出product1的首地址
```

### 11.1.4 结构体类型的初始化
结构体类型与其他基本类型一样，也可以在定义结构体变量时指定初始值。例如，
```C
struct Student
{
	char cName[20];
	char cSex;
	int iGrade;
} student1={"HanXue","W",3};		// 定义结构体变量并设置初始值
```
定义的变量后面使用等号，初始化值放在大括号中，数据顺序与结构体的成员列表顺序一致。
**注意**
并不是所有的结构体成员都可以赋值，如果某个成员使用const做了限定，就不可能再对其赋值。

## 11.2 结构体数组
当要定义10个整型变量时，可以使用数组的形式。当要定义10个结构体变量时，也可以使用数组的形式，这时的数组被称为结构体数组。
结构体数组与普通数组的**区别**在于：数组中的每个元素都是根据要求定义的结构体类型，而不是基本类型。

### 11.2.1 定义结构体数组
定义结构体数组的方式与定义结构体变量的方法相同，其一般形式如下：
```C
struct 结构体名
{
	 成员列表;
} 数组名;
```
例如，定义一个学生信息的结构体数组，其中包含5个学生的信息，代码如下：
```C
struct Student		// 学生结构体
{
	char cName[20];		// 姓名
	int iNumber;		// 学号
	char cSex;		// 性别
	int iGrade;		// 年级
} student[5];		// 定义结构体数组
```
上述代码中，定义结构体类型的同时定义了结构体数组student[5]。除此以外，也可以先声明结构体类型再定义结构体数组：
```C
struct Student student[5];		// 定义结构体数组
```
或者直接定义结构体数组（此时不需要给出结构体名称）：
```C
struct		// 学生结构体
{
	 ……		// 成员列表，省略过程
} student[5];		// 定义结构体数组
```

### 11.2.2 初始化结构体数组
初始化结构体数组的一般形式如下：
```C
struct 结构体名
{
	 成员列表;
} 数组名={初始值列表};
```
例如，为学生结构体数组进行初始化操作，代码如下：
```C
struct Student		// 学生结构体
{
	char cName[20];		// 姓名
	int iNumber;		// 学号
	char cSex;		// 性别
	int iGrade;		// 年级
} student[1]={ { "Wangjiasheng", 120334532535, 'M', 3 } };		// 定义数组并设置初始值
```
为数组进行初始化时，最外层的大括号表示列出的是数组中的元素。因为每个元素都是结构体类型，所以也都使用大括号括起来，其中包括每一个结构体元素的成员数据。
定义数组student时，也可以不指定数组中的元素个数，这时编译器会根据数组后面的初始化值列表中给出的个数，来确定数组中元素的个数。例如，
```C
student[]={……};
```
同样，也可以先声明结构体数组，后续再进行初始化。

## 11.3 结构体指针
定义结构体指针的一般形式如下：
```C
结构体类型 *指针名;
```
例如，定义一个指向struct Student结构类型的pStruct指针变量，代码如下：
```C
struct Student *pStruct;
```
指针指向的结构体变量的地址，因此可以使用指针来访问结构体中的成员，方式有两种。
第一种方法就是使用成员运算符“.”引用结构成员，形式为“(`*`pStruct).成员名”。例如，pStruct指针指向student结构体变量，可以采用如下方式引用引用其中的成员。
```C
(*pStruct).iNumber=12061212;
```
**注意**
`*`pStruct一定放在括号内，这是因为成员运算符“.”的优先级最高，如果不使用括号，就会先执行“.”运算然后才是“* ”运算。

第二种方法是使用指向运算符“->”引用结构成员，形式为“pStruct -> 成员名”。例如，
```C
pStruct -> iNumber = 12061212;
```
**注意**
在使用“->”引用成员时，要注意分析以下情况。
+ pStruct->iGrade：表示指向的结构体变量中成员iGrade的值。
+ pStruct->iGrade++：表示指向的结构体变量中成员iGrade的值，使用后该值加1。
+ ++pStruct->iGrade：表示指向的结构体变量中成员iGrade的值加1，计算后再进行使用。

总结以下，假如student为结构体变量，pStruct为指向结构体变量的指针，则以下3种形式的效果是完全等价的。
+ student.成员名
+ (`*`pStruct).成员名
+ pStruct->成员名

### 11.3.2 指向结构体数组的指针
结构体指针变量指向结构体数组时，指针变量的值就是结构体数组的首地址。还可以直接指向结构体数组中的元素，这时指针变量的值就是该结构体数组元素的首地址。
例如，定义一个结构体数组student[5]，使用结构体指针指向该数组，代码如下：
```C
struct Student* pStruct;
pStruct=student;
```

因为数组不使用下标时表示的是数组的第一个元素的地址，所以指针指向数组的首地址。如果想利用指针指向第3个元素，则在数组名后附加下标，然后在数组名前使用取地址符号“&”。
```C
pStruct=&student[2];
```

**注意**
(++pStruct)->Number与(pStruct++)->Number的区别在于：前者先执行++操作，使pStruct指向下一个元素的地址，然后取得该元素的成员值；后者先取得当前元素的成员值，再使pStruct指向下一个元素的地址。

### 11.3.3 结构体作为函数参数
使用函数时，其参数也可以是结构体变量。形式有3种：使用结构体变量作为函数参数；使用指向结构体变量的指针作为函数参数；使用指向结构体变量的指针作为函数参数；使用结构体变量的成员作为函数参数。
1. 使用结构体变量作为函数参数

结构体变量作为函数实参时，采取的是“值传递”方式，即会将结构体变量所占内存单元的内容全部顺序传递给形参，形参也必须是同类型的结构体变量。例如，
```C
void Display(struct Student stu);
```
在形参位置使用结构体变量，但是函数调用期间，形参也要占用内存单元。这种传递方式在空间和时间上开销都比较大。另外，根据函数参数传值方式，如果在函数内部修改了变量中成员的值，则改变的值不会返回到主调函数中。
………………………………………………………………………………
……………………………………………………………………………………………………
此处省略N个字………………




# 第12章 位运算
C语言可用来代替汇编语言，完成大部分的系统开发及底层驱动开发工作，其中一个重要原因就是C语言完全支持按位运算。

## 12.1 位与字节
数据在内存中是以二进制的形式存放的。位是计算机存储数据的最小单位，一个二进制位可以表示0、1两种状态，多个二进制位组合起来便可表示多种信息。
一个字节通常由8位二进制数组成(有的计算机系统由16位组成)。

## 12.2 位运算操作符
C语言既具有高级语言的特点，又具有低级语言的功能，C语言完全支持按位运算，而且能像汇编语言一样编写系统程序。本节将介绍如何在位一级进行运算。
按位运算也就是对字节或字中的实际位进行检测、设置或移位。如表所示C语言提供的6类位运算符。
| 位运算符 | 含义 | 位运算符 | 含义 |
| --- | --- | --- | --- |
| & | 按位与 | ^ | 按位异或 |
| \| | 按位或 | << | 左移 |
| ~ | 取反 | >> | 右移 |

### 12.2.1 按位与运算符








 




# 第13章 预处理
预处理是C语言特有的功能，包括宏定义、条件编译等。使用预处理功能可使程序的修改、阅读、移植和调试更加方便，也更利于实现模块化程序设计。

## 13.1 宏定义
宏定义是预处理命令的一种，它提供了一种可以替换源代码中字符串的机制。简单来说，宏定义指令#define用来定义一个标识符和一个字符串，以这个标识符来代表这个字符串，在程序中每次遇到该标识符时就用所定义的字符串替换它。宏定义的作用相当于给指定的字符串起了一个别名。
**说明**
C语言并没有规定#define必须写在函数外面，只是规定这条命令必须独占一格完整的逻辑行。，其作用范围是#define出现的位置到所在源文件结束，或到相应的#define预处理指令处。如果需要#define预处理命令仅在某个函数内有关，完全可以把它写在函数内。

### 13.1.1 不带参数的宏定义
不带参数的宏定义，其一般形式如下：
```C
#define 宏名 字符串
```
+ “#”表示这是一条预处理命令
+ 宏名是一个标识符，必须符合C语言中对标识符的限定。宏名要简单且意义明确，一般习惯用大写字母表示，以便与变量名相区别。
+ 字符串可以是常数、表达式、格式字符串等。

例如，下面宏定义的作用是在程序中用PI替代3.14159。编译预处理时，每当在源程序中遇到PI，就自动用3.14159代替。**注意**，宏定义不是C语句，不需要在行末加分号。
```C
#define PI 3.14159
```
使用#define进行宏定义的好处是：当需要改变一个常量时，只需改变#define命令行，整个程序的常量都会改变，大大提高了程序的灵活性。
宏定义后，即可成为其他宏名定义中的一部分。例如，下面代码定义了正方形的边长SIDE、周长PERIMETR及面积AREA的值。
```C
#define SIDE 5
#define PERIMETER 4*SIDE
#define AREA SIDE*SIDE
```
前面强调过，宏替换是以字符串代替标识符。因此，可定义一个标准的邀请语：
```C
#define STANDARD "You are welcome to join us."
printf(STANDARD);
```
编译程序时，遇到标识符STANDARD，就用"You are welcome to join us."替换。
关于不带参数的宏定义，有以下几点需要注意。
+ 如果在字符串中出现宏名，则不进行替换。例如：

```C
#include<stdio.h>
#define TEST "this is an example"
main()
{
	char exp[30]="This TEST is not that TEST";		// 定义字符数组并赋初值
	printf("%s\n", exp);
}
```
上述代码的输出结果，可见，字符串中的两处TEST并没有用"this is an example"替换。
+ 如果字符串多于一行，可在行末用反斜杠“\”进行续行。
+ #define命令出现函数外时，宏名的有效范围为定义命令之后到此源文件结束。

**注意**
通常会将所有#define放到文件开始处或独立的文件中，而不是将它们分散到整个程序中。

+ 可以用#undef命令终止宏定义的作用域，例如，

```C
#include<stdio.h>
#define TEST "this is an example"
main()
{
	printf(TEST);
	#undef TEST
}
```
+ 宏定义是一种预处理命令，不同于变量定义，它只做字符替换，而不分配内存空间。

### 13.1.2 带参数的宏定义
带参数的宏定义，不仅要进行字符串替换，还要进行参数替换。其一般形式如下：
```C
#define 宏名(参数表)字符串
```
例，两个数混合运算
要求对两个数实现乘法和加法混合运算，代码如下：
```C
#include<stdio.h>
#define MIX(a,b)((a)*(b)+(b))		// 宏定义，求两个数的混合运算
main()
{
	int x=5, y=9;
	printf("x,y:\n");
	printf("%d,%d\n", x, y);
	printf("the min number is:%d\n", MIX(x,y));		// 宏定义调用
}
```


用宏替换代替实在的函数，好处是可以提升代码速度(不再存在函数调用)，代价是由于重复编码，增加了程序长度。
对于带参数的宏定义，有以下几点需要注意。
+ 宏定义时，参数要加括号。如不加括号，则结果可能是正确的，也可能是错误的。
例，宏定义语句改为：
```C
#define MIX(a,b)(a*b+b)		// 宏定义，求两个数的混合运算
```
则main函数中，x=10,y=9时调用MIX(x,y)，可以输出正确结果99；x=10,y=3+4时调用MIX(x,y)，执行情况为(10* 3+4+3+4)，将输出错误结果为41。因此，宏定义时一定要给参数加上括号。
+ 宏扩展必须使用括号来保护表达式中优先级低的操作符，以确保调用时能达到预期效果。
+ 对带参数的宏的展开，只是用宏名后括号内的实参字符串代替#define命令行中的形象。
+ 宏定义时，宏名与带参数的括号之间不要加空格，否则会将空格以后的字符都作为替代字符串的一部分。
+ 在带参宏定义中，形式参数不分配内存单元，因此不必做类型定义。

## 13.2 #include命令
使用#include命令可将其他源文件的内容包含进来，即将其他文件包含到本文件之中。被读入的源文件必须用双引号或尖括号括起来。
例如，下面两行代码均包含了标准输入\输出库文件stdio.h，后续可直接使用其中的函数而不用再定义。
```C
#include"stdio.h"
#include<stdio.h>
```
双引号和尖括号的区别是：
+ 尖括号：此为标准方式，系统会直接到存放C库函数头文件所在的目录中寻找要包含的文件。
+ 双引号：系统先在用户当前目录中寻找要包含的文件，若找不到，再到存放C库函数头文件所在的目录中寻找要包含的文件。

通常情况下，包含库函数时，使用尖括号可以节省查找时间；包含用户自定义文件时，使用双引号比较快捷。用户自己编写的文件通常保存在当前目录中，如果文件不在当前目录中，双引号内还可以给出文件路径。
将文件直接嵌入#include命令内也是可行的，这种方式成为嵌套的嵌入文件。嵌套层次依赖于具体实现。

例，一年长一岁
(1)文件age.h
```C
#define P printf		// 定义头文件
#define D "%d"
#define A (age+1)
```
(2)文件age.c
```C
#include "stdio.h"		// 包含头文件
#include "age.h"		// 包含自定义头文件
int main()		// 主函数
{
	int age=3;		// 定义变量
	age=A;		// 引用头文件包括内容
	P("年龄是"D"岁\n", age);		// 输出结果
	return 0;		// 程序结束
}
```
经常用在文件头部的被包含文件称为标题文件或头文件，一般以.h为后缀。一般情况下，将如下内容放到.h头文件。
+ 宏定义
+ 结构、联合和枚举声明。
+ typedef声明。
+ 外部函数声明。
+ 全局变量声明。

使用文件包含为实现程序修改提供了方便。当需要修改某些参数时，不必逐个修改程序，只需修改一个文件（头部文件）即可。
关于文件包含，有以下几点需要注意。
+ 一个#include命令只能指定一个被包含的文件。
+ 文件包含是可以嵌套的，即在一个被包含文件中还可以包含另一个被包含文件。
+ 若age.c中包含文件age.h，则预编译后两者会成为一个文件。如果age.h中有全局静态变量，则该全局变量在age.c文件中也有效，这时不需要再用extern声明。

## 13.3 条件编译
C语言预处理器提供了条件编译功能。一般情况下，源程序中的所有行都会参加编译。如果希望其中一部分内容只在满足一定条件时才进行编译，这时就需要使用条件编译命令。使用条件编译可以非常方便地处理程序的调试版本和正式版本，同时还会增强程序的可移植性。

### 13.3.1 #if命令
#if的基本含义是：如果#if命令后的参数表达式为真，则编译#if到#endif之间的程序段，否则跳过这段程序。#endif命令用来表示#if段的结束。
#if命令的一般形式如下：
```C
#if 常数表达式
    语句段
#endif
```
如果常数表达式为真，则该段程序被编译，否则跳过该段程序(不编译)。
例，与50进行比较
本实例中，用#if和#define实现与50进行比较。如果等于50，就计算i=i+50；如果大于50，就计算i++；如果小于50，就计算i--。具体代码如下：
```C
#include<stdio.h>
#define NUM 50
main()
{
    int i=0;
    #if NUM > 50    // 判断NUM是否大于50
      i++;
    #endif
    #if NUM = 50
      i=i+50;
    #endif
    #if NUM < 50
      i--;
    #endif
    printf("目前的值是::%d\n", i);
}
```
#else的作用是为#if为假时提供另一种选择，其作用和前面讲过的条件判断中的else相近。
#elif指令用来建立“如果……或者如果…………”这样阶梯状多重编译操作选择，与多分支if语句中else if类似。
#elif的一般形式如下：
```C
#if 表达式1
    语句段1
#elif 表达式2
    语句段2
#elif 表达式3
    语句段3
  …………
#elif 表达式n
    语句段n
#endif
```

### 13.3.2 #ifdef及#ifndef命令
在#if条件编译命令中，需要判断符合常量所定义的具体值。但有时并不需要判断具体值，只需要知道这个符号常量是否被定义了，这时可以采用另一种条件编译的方法，即#ifdef与#ifndef命令，分别表示“如果有定义”及“如果无定义”。
#ifdef的一般形式如下：
```C
#ifdef 宏替换名
    语句段
#endif
```
其含义是：如果宏替换名已被定义过，则对语句段进行编译；如果未定义#ifdef后面的宏替换名，则不对语句段进行编译。#ifdef可与#else连用，形式如下：
```C
#ifdef 宏替换名
    语句段1
#else
    语句段2
#endif
```
其含义是：如果宏替换名已被定义过，则对语句段1进行编译；如果未定义#ifdef后面的宏替换名，则对语句段2进行编译。
#ifndef的一般形式如下：
```C
#ifndef 宏替换名
    语句段
#endif
```
其含义是：如果未定义#ifndef后面的宏替换名，则对语句段进行编译；如果定义#ifndef后面的宏替换名，则不执行语句段。同样，#ifndef也可以与#else连用，一般形式如下：
```C
#ifndef 宏替换名
    语句段1
#else
    语句段2
#endif
```
其含义是：如果未定义#ifndef后面的宏替换名，则对语句段1进行编译；如果定义#ifndef后面的宏替换名，则对语句段2进行编译。

### 13.3.3 #undef命令
使用#undef命令可以删除事先定义好的宏定义。其一般形式如下：
```C
#undef 宏替换名
```
使用#undef命令可将宏名限制在特定的代码段中。例如，
```C
#define MAX_SIZE 100
char array[MAX_SIZE];
#undef MAX_SIZE
```
上述代码中，首先使用#define定义标识符MAX_SIZE，然后使用#undef删除宏定义。也就是说，遇到#undef语句之前，MAX_SIZE的定义都是有效的。

### 13.3.4 #line命令
#line命令用于显示_LINE_与_FILE_的内容。\_LINE_用于存放当前编译行的行号，\_FILE_用于存放当前编译的文件名。#line命令的一般形式如下：
```C
#line 行号["文件名"]
```
其中，行号为任一正整数，可选的文件名为任意有效文件标识符。行号为源程序中当前行号，文件名为源文件的名字。#line命令主要用于调试及其他特殊应用。

### 13.3.5 #pragma命令
1. #pragma命令

#pragma命令用于设定编译器状态，或指示编译器完成一些特定动作。一般形式如下：
```C
#pragma 参数
```
+ message参数：在编译信息窗口中输出的相应信息。
+ code_seg参数：设置程序中函数代码存放的代码段。
+ once参数：保证头文件被编译一次。

2. 预定义宏名

ANSI标准说明了以下5个预定义宏替换名。
+ \_LINE_：当前被编译代码的行号。
+ \_FILE_：当前源程序的文件名称。
+ \_DATE_：当前源程序的创建日期。
+ \_TIME_：当前源程序的创建时间。
+ \_STDC_：判断当前编译器是否为标准C。其值为1，是标准C，否则不是标准C。

宏名的书写比较特别，书写时两边都要由下划线构成。如果编译不是标准的，则可能仅支持以上宏名中的几个，或根本不支持。编译程序有时还提供其他预定义的宏名。


# 第14章 文件
文件是一组相关数据的有序集合，这个数据集有一个名称，叫作文件名。
所有文件都可以通过流进行输入、输出操作。与文本流和二进制流相对应。文件可以分为文本文件和二进制文件两大类。文本文件也称为ASCII文件，保存时每个字符对应一个字节，存放对应的ASCII码。二进制文件按二进制编码方式保存文件内容。
按文件内容看，可分为源文件、目标文件、可执行文件、头文件和数据文件等。
从用户角度(或所依附的介质)看，文件可分为普通文件和设备文件两种。
+ 普通文件：指驻留在磁盘或其他外部介质上的一个有序数据集。
+ 设备文件：指与主机相连的各种外部设备，如显示器、打印机、键盘等。操作系统中把外部设备也看作一个文件来进行管理，把它们的输入、输出等同于对磁盘文件的读和写。

C语言中，文件操作都是由库函数来完成的。

## 14.2 文件基本操作
文件的基本操作包括文件的打开和关闭。除标准的输入、输出文件外，其他所有文件都必须先打开再使用，使用后还必须关闭该文件。

### 14.2.1 文件指针
文件指针是一个指向文件有关信息的指针，这些信息包括文件头、状态和当前位置，保存在一个结构体变量中。使用文件时需要在内存中为其分配空间，用来存放文件的基本信息。该结构体类型是由系统定义的，C语言规定该类型为FILE型，其声明如下：
```C
typedef struct
{
	short level;
	unsigned flags;
	char fd;
	unsigned char hold;
	short bsize;
	unsigned char *buffer;
	unsigned ar*curp;
	unsigned istemp;
	short token;
}FILE;
```
上述代码中，使用typedef定义了一个FILE结构体类型，编写程序时可直接使用FILE类型来定义变量。注意，定义变量时不必将结构体内容全部给出，只需写成如下形式（fp是一个指向FILE类型的指针变量）：
```C
FILE *fp;
```
**说明**
不可通过定义FILE类型变量来操作文件。FILE型数据对象的位置由库函数确定，C语言中只能通过FILE \*类型的指针来操作文件。

### 14.2.2 文件的打开
fopen函数用来打开一个文件，打开文件的操作就是创建一个流。fopen函数的原型在stdio.h中，其调用形式一般如下：
```C
FILE *fp;
fp=fopen(文件名,使用文件方式);
```
其中，“文件名”是将要被打开文件的文件名，“使用文件方式”是指对打开文件进行的读写方式。见下表。
| 文件使用方式 | 含义 |
| --- | --- |
| r(只读) | 打开一个文本文件，只允许读数据 |
| w(只写) | 打开或建立一个文本文件，只允许写数据 |
| a(追加) | 打开一个文本文件，并在文件末尾写数据 |
| rb(只读) | 打开一个二进制文件，只允许对数据 |
| wb(只写) | 打开或建立一个二进制文件，只允许写数据 |
| ab(追加) | 打开一个二进制文件，并在文件末尾写数据 |
| r+(读写) | 打开一个文本文件，允许读写 |
| w+(读写) | 打开或建立一个文本文件，允许读写 |
| a+(读写) | 打开一个文本文件，允许读，或在文件末追加数据 |
| rb+(读写) | 打开一个二进制文件，允许读和写 |
| wb+(读写) | 打开或建立一个二进制文件，允许读和写 |
| ab+(读写) | 打开一个二进制文件，允许读，或在文件末追加数据 |

例如，以只读方式打开名为123的文本文档文件，代码如下：
```C
FILE *fp;
fp=fopen("123.txt", "r");
```
如果使用fopen函数打开文件成功，则返回一个有确定指向的FILE类型指针；若打开失败，则返回NULL。文件打开失败的原因通常是以下3个方面：
+ 指定的盘符或路径不存在。
+ 文件名中含有无效字符。
+ 以r模式打开一个不存在的文件。

### 14.2.3 文件的关闭
文件使用完毕后，应使用fclose函数将其关闭。fclose函数的原型也在stdio.h中，调用形式如下：
```C
fclose(文件指针);
```
正常完成关闭文件操作时，fclose函数的返回值为0，否则返回EOF。例如：
```C
fclose(fp);
```
**说明**
在程序结束之前应关闭所有文件，这样做的目的是防止因为没有关闭文件而造成的数据丢失。

## 14.3 文件的读写
打开文件后，可对文件进行读出或写入的操作。C语言提供了丰富的文件操作函数。

### 14.3.1 fputc函数
fputc函数用于把一个字符写到磁盘文件(fp所指向的文件)中。其一般形式如下：
```C
ch=fputc(ch, fp);
```
其中，ch是要写入的字符，可以是一个字符常量，也可以是一个字符变量。fp是文件指针变量，如果函数写入成功，则返回值就是写入的字符；如果写入失败，则返回EOF。



















































































