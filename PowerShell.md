### 3.5.1 参数集和通用参数
大部分命令可以有很多不同的使用方式，这依赖于你需要用它们来干什么。例如，下面是Get-EventLog的语法帮助部分。
```PowerShell
SYNTAX
    Get-EventLog [-AsString] [-ComputerName <string[]>] [-List] [<CommonParameters>]

Get-EventLog [-LogName] <string> [[-InstanceId] <Int64[]>] [-After <DateTime>]
[-AsBaseObject] [-Bfore <DateTime>] [-ComputerName<string[]>] [-EntryType <string[]>] [-Index <Int32[]>] [-Message<string>] [-Newest <int>] [-Source <string[]>] [-UserName <string>] [<CommonParameters>]
```
**注意** 这个命令在语法部分出现了两次，这表示这个命令提供了两个不同的参数集，你可以有两种方式来使用这个命令。你可能已经注意到，有些参数是这两个参数集共享的。例如，这两个参数集都包含-ComputerName参数。但是这两个参数集总是会有些差异。在这个实例中，第一个参数集提供了-AsString和-List，这两个参数都没有出现在第二个参数集中；而第二个参数集包含许多第一个参数集中没有的参数。
下面来说明它们是如何工作的：如果你使用一个只包含在某个参数集中的参数，那么你就只能使用同一个参数集里的其他参数。如果你选择使用-List参数，那么你能使用的其他参数就只能是-AsString和-ComputerName，因为存在-List的参数集中只剩这两个参数可以选择了。你不能添加-LogName参数，因为它不存在于第一个参数集中。这意味着-List和-LogName是相互排斥的，即你不能同时使用它们，因为它们存在于不同的参数集中。
有些时候，可以只运行命令参数集中共同的参数部分。在这种情况下，Shell通常会选择第一个参数集。明白你运行的命令属于哪个参数集是非常重要的，因为每个参数集意味着不同的功能。你可能已经注意到，在每个PowerShell的Cmdlet参数的结尾都有[<CommonParameters>]。不管你以何种方式使用Cmdlet，这泛指每个Cmdlet命令都是使用的一组包含8个参数的集合。现在暂时不讨论通用参数，我们会在本书后面章节真正使用它们的时候来讨论。不过，在本章后面，如果你有兴趣，我们会告诉你哪里可以学习到更多关于通用参数的知识。
**谨记** 如果你访问[Windows PowerShell实战指南 第二版](http://MoreLunches.com,)，并在首页搜索这本书(译者注：本书的英文名)，你会获得各种免费配套材料。
### 3.5.2 可选和必选参数
运行一个Cmdlet命令，你不需要提供全部参数。PowerShell的帮助文档把可选参数放到一个方括号中。例如，[-ComputerName <string[]>] 表示整个-ComputerName参数是可选的。你可以根本不使用它，因为在没有为这个参数指定一个具体值的时候，Cmdlet会默认为本地计算机。这也就是为什么[<CommonParameters>]在方括号内，你就可以不使用任何通用参数的情况下运行这个命令。
几乎所有的Cmdlet命令都最少有一个可选参数。你可能永远不会需要使用其中的一些参数，你或许只需要使用其他日常参数。记住，当你选择一个参数时，你只需输入足够的参数名称就可以让PowerShell明确找出参数的意思。例如，-L不能充分表示-List，因为-L可以表示-LogName。但是-Li会是-List的一个合适的缩写，因为其他参数没有以-Li开头的。
如果你在运行命令但忘记了指定必选参数，会发生什么事情呢？来看看Get-EventLog的帮助。例如，你可以看到-LogName参数是具有强制性的，这个参数不是以方括号结束的。尝试在没有指定日志名称的情况下运行Get-EventLog。
### 3.5.3 定位参数
PowerShell设计师知道有些参数会被频繁地使用，而你不希望不断地输入参数名。通常来说，参数是具有位置性的。这意味着只要你把参数值放在正确的位置，你就可以只提供这个参数值，而不需要输入具体的参数名。
有两种方式可以用来确定**定位参数**：通过语法概要或者通过详细的帮助文档。
**在语法概要中找到定位参数**
你可以在语法概要中找到第一种方式：只有参数名被方括号括起来的参数。比如，查看Get-EventLog的第二个参数集的前两个参数：
```PowerShell
[-LogName] <string> [[-InstanceId] <Int64[]>]
```
第一个参数：-LogName。它是必选的。我们可以识别出它是必选参数，是因为它的参数名和参数值不在一个方括号里面。但是它的参数名处在一个方括号内，这让它成了一个定位参数，所以我们可以只提供日志名称而不需要输入参数名-LogName。并且因为这个参数出现在帮助文档的第一个位置，所以我们知道这个日志名称是我们必须提供的第一个参数。
第二个参数：-InstanceId。它是可选的，因为它的参数名和参数值放在同一个方括号内。在方括号内，-InstaceId本身又处在一个方括号里，意味着它同时还是一个定位参数。它出现在第二个位置，所以我们省略这个参数名，就必须在这个位置提供一个参数值。
参数-Before(出现在语法的后面，通过运行Help Get-EventLog命令自行查找)是一可选参数，因为参数名和参数值同在一个方括号里面。-Before参数名没有单独放在方括号里，这高诉我们，当选择使用这个参数是，必须输入这个参数名(或者最少是它的别名)。
使用定位参数时的几个技巧。
+ 定位参数可以同时出现指定和不指定参数名的情况，但是定位参数必须处在正确的位置。例如，Get-EventLog -newest 20 -Log Application是正确的；System会被匹配到-LogName参数，以为这是第一个位置的参数值，20将表示-Newest参数值，因为你已经使用了参数名。
+ 指定参数名总是正确的。当你这么做了，输入的顺序就变得不重要。Get-EventLog-newest 20-LogApplication是正确的，因为我们已经使用了参数名(在这个示例中是-LogName，我们这里使用了缩写-Log)。
+ 如果使用多个定位参数，不要忘了它们的位置。Get-EventLog Application 0 是可以运行的，Application会附加到-LogName参数，0会附加到-InstanceId参数。Get-EventLog 0 Application 会运行失败，因为0会附加-LogName参数名，但是却找不到名为“0”的日志。
### 3.5.4 参数值
帮助文档同样给你提供了每个参数的数据类型。有些参数被称为开关参数，无需任何输入值。在概要语法中它们看起来如下所示。
```PowerShell
[-AsString]
    在详细语法中，它们看起来如下所示。
-AsString [<SwitchParameter>]
    以字符串而非对象的形式返回输出。
    是否必需？              False
    位置？                  named
    默认值
    是否接受管道输入？      False
    是否接受通配符？        False
```
通过[<Switchparameter>]可以确认这是一个开关参数，并不需要任何输入值。开关参数的位置可以随意放置，你必须输入参数名(或者至少是一个缩写)。开关参数总是可选的，这可以让你选择是否使用它们。
其他参数希望获得的数据类型，通常会跟在参数名之后，并使用空格与参数名分开(不是冒号、等号或者其他字符)。在概要语法里面，输入的类型使用尖括号来表明，例如<>:
```PowerShell
[-LogName] <string>
    再详细语法中以相同的方式显示：
-Message <string>

    获取其消息中具有指定字符串的事件。可以使用此属性来搜索包含特定单词或短语的消息。允许使用通配符。
    是否必需?           False
    位置？              named
    默认值              
    是否接受管道输入?    False
    是否接受通配符?      True
```
